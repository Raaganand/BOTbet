# -*- coding: utf-8 -*-
"""Streamlit.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_pOM2tpFusAKD9nebWahWsfU4sshG3Np
"""

!pip install streamlit
import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder, StandardScaler
import joblib
import streamlit as st

@st.cache(allow_output_mutation=True)
def load_models():
    rf_model = joblib.load('random_forest_model.pkl')
    svm_model = joblib.load('svm_model.pkl')
    team_encoder = joblib.load('team_encoder.pkl')
    scaler = joblib.load('scaler.pkl')
    return rf_model, svm_model, team_encoder, scaler

# Load the models and label encoders
rf_model, svm_model, team_encoder, scaler = load_models()

# Define a function for making predictions
def make_prediction(home_team_name, away_team_name, home_score, away_score, referee):
    # Add missing team names to the label encoder
    team_encoder.classes_ = np.append(team_encoder.classes_, [home_team_name, away_team_name])

    # Map the original team names to encoded values
    home_team_encoded = team_encoder.transform([home_team_name])[0]
    away_team_encoded = team_encoder.transform([away_team_name])[0]

    # Create a DataFrame for prediction
    prediction_data = pd.DataFrame({
        'HomeTeam': [home_team_encoded],
        'AwayTeam': [away_team_encoded],
        'Home_Score': [home_score],
        'Away_Score': [away_score],
        'Referee': [referee]
    })

    # Apply preprocessing steps to the prediction data
    prediction_data = prediction_data.astype(float)  # Ensure data type is float

    # Standardize the features using the pre-trained scaler
    columns_to_standardize = ['Home_Score', 'Away_Score']
    prediction_data[columns_to_standardize] = scaler.transform(prediction_data[columns_to_standardize])

    # Make predictions using the ensemble model
    rf_predictions = rf_model.predict(prediction_data)
    svm_predictions = svm_model.predict(prediction_data)
    ensemble_predictions = (rf_predictions + svm_predictions) // 2  # Voting/averaging

    # Map the predicted values back to original labels
    result_mapping = {0: 'Loss', 1: 'Win', 2: 'Draw'}
    predicted_result = result_mapping[ensemble_predictions[0]]

    return predicted_result

# Create the Streamlit app
def main():
    st.title("Football Match Result Predictor")

    # Get user inputs
    home_team_name = st.text_input("Enter the name of the home team:")
    away_team_name = st.text_input("Enter the name of the away team:")
    home_score = st.number_input("Enter the home score:", value=0, min_value=0)
    away_score = st.number_input("Enter the away score:", value=0, min_value=0)
    referee = st.number_input("Enter the referee (encoded value):", value=0, min_value=0)

    if st.button("Predict"):
        # Make the prediction
        predicted_result = make_prediction(home_team_name, away_team_name, home_score, away_score, referee)

        # Display the prediction result
        st.success(f"The predicted result for {home_team_name} vs {away_team_name} is {predicted_result}")

if __name__ == "__main__":
    main()